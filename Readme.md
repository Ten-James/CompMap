# CompileMapper (TenJames.CompMap)

> CompMap is a C# Roslyn-based source generator that automatically creates mapping methods between classes. It simplifies the process of converting one class type to another by generating the necessary code at compile time.

Ensure your DTO's are correctly mapped with compile time safety, to ensure valid changes are tracked in your project.

```csharp
//generated UserReadDto.g.cs
// <auto-generated/>
using System;
using System.Collections.Generic;

using TenJames.CompMap.Mappper;

namespace TenJames.CompMap.Example;

partial class UserReadDto
{

    ///<summary>
    /// The following properties were not mapped because they do not exist in the target class
    ///</summary>
    internal class UserUnmappedProperties
    {
        /// <summary>
        /// Found at /Entitities.cs at 29
        /// </summary>
        public required string Title { get; set; }
    }

    private static partial UserUnmappedProperties GetUserUnmappedProperties(IMapper mapper,  User source);

    /// <summary>
    /// Mapping method generated by TenJames.CompMap
    /// </summary>
    public static UserReadDto MapFrom(IMapper mapper, User source)
    {
        // Note: Some properties were not mapped due to missing counterparts in the target class.
        var unmapped = GetUserUnmappedProperties(mapper, source);
        return new UserReadDto
        {
            Id = source.Id,
a            Name = source.Name,
            Guid = source.Guid,
            Documents = mapper.Map<ICollection<DocumentDto> >(source.Documents),
            Title = unmapped.Title,
        };
    }
}


```

Which can be generated simply from:


```csharp
using TenJames.CompMap.Attributes;

// Entity

public class User {
    public int Id { get; set; }
    public string Name { get; set; }
    public Guid Guid { get; set; }
    public ICollection<Document> Documents { get; set; }
}

// DTOs

[MapFrom(typeof(User))]
public partial class UserReadDto {
    public int Id { get; set; }
    public string Name { get; set; }
    public Guid Guid { get; set; }
    public required string Title { get; set; }
    public ICollection<DocumentDto> Documents { get; set; }

    //Compile time ensurence of type safety
    private static partial UserUnmappedProperties GetUserUnmappedProperties(IMapper mapper, User source)
    {
        return new UserUnmappedProperties()
        {
            // All using Easy to use Mapping methods
            Title = source.Name + "'s Title",
        };
    }
}

```

## Getting started

Install the **TenJames.CompMap** package via NuGet:

```shell
dotnet add package TenJames.CompMap
```
Ensure its correclty referenced in your project file:

```xml
<ProjectReference 
    Include="TenJames.CompMap" 
    Version="0.0.2" 
    ReferenceOutputAssembly="false" 
    OutputItemType="Analyzer" 
/>
```

### Component registration

If you are using dependency injection, register the mapping services in your DI container:

```csharp
using TenJames.CompMap.Mapper;

...

// Feel free to try with Extending BaseMap for custom mapping logic
services.AddTransient<IMapper, BaseMap>();
```

### Usage

Add Attributes to your DTO classes and then enjoy the generated mapping methods :)


---

## Continuous Integration (GitHub Actions)

A workflow was added at `.github/workflows/ci.yml` to automate verification and publishing:

- On pull requests (opened/synchronized/reopened):
  - Restores, builds the solution and runs tests (if the `TenJames.CompMap.Tests` project exists).
  - If the PR branch belongs to the same repository (not a fork), the workflow increments the patch version in `TenJames.CompMap/TenJames.CompMap/TenJames.CompMap.csproj` (e.g. 0.0.2 -> 0.0.3), commits the change and pushes it back to the PR branch, then adds a comment to the PR with the new version. This helps keep package versions unique for CI package artifacts.

- On push of a tag matching `v*.*.*` (for example `v1.2.3`):
  - The workflow builds the solution, packs `TenJames.CompMap` with the version taken from the tag (strips a leading `v` if present), and attempts to publish the resulting `.nupkg` to NuGet.org.
  - Publishing runs only when a `NUGET_API_KEY` secret is set in the repository settings; otherwise the publish step is skipped.

Notes and requirements:

- Ensure the repository secret `NUGET_API_KEY` is set if you want automatic publishing to NuGet.org.
- The PR auto-bump only runs when the PR head repo equals this repository (forked PRs are skipped to avoid push permission errors).
- The workflow uses `dotnet 10.x` (actions/setup-dotnet@v3). Adjust the SDK version in the workflow if you need a different runtime.

Quick commands (run locally) â€” fish shell:

```fish
# Build and test locally
dotnet restore
dotnet build TenJames.CompMap.sln -c Release
dotnet test TenJames.CompMap/TenJames.CompMap.Tests -c Release

# Create a tag and push (publish via CI)
git tag v1.2.3
git push origin v1.2.3
```

If you'd prefer bumping major/minor instead of patch in PRs, or if you want bumping to commit via a bot account or a separate branch/PR, I can adapt the workflow.

---
