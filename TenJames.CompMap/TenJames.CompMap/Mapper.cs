
// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;
using System.Reflection;

namespace TenJames.CompMap.Mappper;

/// <summary>
/// Interface for mapping between types.
/// </summary>
public interface IMapper
{
    /// <summary>
    /// Tries to map the source object to the destination type.
    /// If the mapping is not defined, by default an exception is thrown.
    /// </summary>
    /// <param name="source">Source for the mapping</param>
    /// <typeparam name="TDestination">Destination type for the map</typeparam>
    /// <returns></returns>
    TDestination Map<TDestination>(object source);
}


/// <summary>
/// Base implementation of IMapper
/// </summary>
public class BaseMapper : IMapper {

    /// <summary>
    /// Default implementation for null source
    /// </summary>
    /// <typeparam name="TDestination">Destination type</typeparam>
    /// <returns></returns>
    protected virtual TDestination OnNull<TDestination>()
    {
        return default(TDestination);
    }

    /// <summary>
    /// Default implementation for mapping
    /// </summary>
    /// <param name="source">the source</param>
    /// <param name="mapToMethod">Method on Source</param>
    /// <param name="mapFromMethod">Method on destination</param>
    /// <typeparam name="TDestination">Destination type</typeparam>
    /// <returns></returns>
    protected virtual TDestination OnMap<TDestination>(object source, MethodInfo? mapToMethod, MethodInfo? mapFromMethod)
    {
        if (mapToMethod != null && mapToMethod.ReturnType == typeof(TDestination))
        {
            return (TDestination)mapToMethod.Invoke(source, new object[] { this });
        }

        // if TDestination has a static method MapFrom
        if (mapFromMethod != null)
        {
            return (TDestination)mapFromMethod.Invoke(null, new object[] { this, source });
        }

        return OnError<TDestination>(source, new NotImplementedException($"No mapping defined from {source.GetType().FullName} to {typeof(TDestination).FullName}"));
    }

    /// <summary>
    /// An error occurred during mapping
    /// </summary>
    /// <param name="source"></param>
    /// <param name="ex"></param>
    /// <typeparam name="TDestination">Destination type</typeparam>
    /// <returns>By default, it always throw</returns>
    /// <exception cref="Exception">By default, it throws an error</exception>
    protected virtual TDestination OnError<TDestination>(object source, Exception ex)
    {
        throw ex;
    }

    /// <summary>
    /// What should happen when source is enumerable
    /// </summary>
    /// <param name="source"></param>
    /// <typeparam name="TDestination">Destination type</typeparam>
    /// <returns>How should collection be mapped</returns>
    protected virtual TDestination OnEnumerable<TDestination>(object source)
    {
        var enumerable = (System.Collections.IEnumerable)source;

        if (typeof(TDestination).IsArray)
        {
            var elementType = typeof(TDestination).GetElementType();
            var listType = typeof(List<>).MakeGenericType(elementType);
            var list = (System.Collections.IList)Activator.CreateInstance(listType);
            foreach (var item in enumerable)
            {
                var mappedItem = this.GetType().GetMethod("Map").MakeGenericMethod(elementType).Invoke(this, new object[] { item });
                list.Add(mappedItem);
            }
            var array = Array.CreateInstance(elementType, list.Count);
            list.CopyTo(array, 0);
            return (TDestination)(object)array;
        }
        if (typeof(TDestination).IsGenericType && ( typeof(TDestination).GetGenericTypeDefinition() == typeof(List<>) ||
                                                    typeof(TDestination).GetGenericTypeDefinition() == typeof(IEnumerable<>)  ||
                                                    typeof(TDestination).GetGenericTypeDefinition() == typeof(ICollection<>)  ||
                                                    false
            ))
        {
            var elementType = typeof(TDestination).GetGenericArguments()[0];
            var list = (System.Collections.IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(elementType));
            foreach (var item in enumerable)
            {
                var mappedItem = this.GetType().GetMethod("Map").MakeGenericMethod(elementType).Invoke(this, new object[] { item });
                list.Add(mappedItem);
            }
            return (TDestination)list;
        }
        else
        {
            return OnError<TDestination>(source, new NotImplementedException($"Mapping to collection type {typeof(TDestination).FullName} is not supported."));
        }
    }


    /// <inheritdoc />
    public virtual TDestination Map<TDestination>(object source)
    {
        switch (source)
        {
            case null:
                return OnNull<TDestination>();

            // if source is iEnumerable
            case System.Collections.IEnumerable enumerable:
                return OnEnumerable<TDestination>(source);
        }


        // if source has a mapping method to TDestination, use it
        var mapMethod = source.GetType().GetMethod("MapTo", new Type[] { typeof(IMapper) });
        var mapFromMethod = typeof(TDestination).GetMethod("MapFrom", new Type[] { typeof(IMapper), source.GetType() });

        return OnMap<TDestination>(source, mapMethod, mapFromMethod);
    }
}

