using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace TenJames.CompMap;

[Generator]
public class AttributeGenerator: IIncrementalGenerator {

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        RegisterAttributes(context);
    }
    
    private void RegisterAttributes(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            var attributes = AttributeDefinitions.GetAllAttributes();
            foreach (var attribute in attributes)
            {
                var sourceText = GenerateAttributeSourceText(attribute);
                ctx.AddSource($"{attribute.Name}Attribute.g.cs", sourceText);
            }
            ctx.AddSource("Mapper.g.cs", GenerateMapperClass());
        });
    }
    
    private static SourceText GenerateMapperClass()
    {
        var sourceText = SourceText.From(
        $$"""
          // <auto-generated/>
          #nullable enable
          using System;
          using System.Collections.Generic;
          using System.Reflection;
          
          namespace TenJames.CompMap.Mappper;
          
          /// <summary>
          /// Interface for mapping between types.
          /// </summary>
          public interface IMapper
          {
              TDestination Map<TDestination>(object source);
          }
          
          
          public class BaseMapper : IMapper {
              
              protected virtual TDestination OnNull<TDestination>()
              {
                  return default(TDestination);
              }
              
              protected virtual TDestination OnMap<TDestination>(object source, MethodInfo? mapToMethod, MethodInfo? mapFromMethod)
              {
                  if (mapToMethod != null && mapToMethod.ReturnType == typeof(TDestination))
                  {
                      return (TDestination)mapToMethod.Invoke(source, new object[] { this });
                  }
          
                  // if TDestination has a static method MapFrom
                  if (mapFromMethod != null)
                  {
                      return (TDestination)mapFromMethod.Invoke(null, new object[] { this, source });
                  }
                  
                  return OnError<TDestination>(source, new NotImplementedException($"No mapping defined from {source.GetType().FullName} to {typeof(TDestination).FullName}"));
              }
              
              protected virtual TDestination OnError<TDestination>(object source, Exception ex)
              {
                  throw ex;
              }
          
              protected virtual TDestination OnEnumerable<TDestination>(object source)
              {
                  var enumerable = (System.Collections.IEnumerable)source;
                  
                  if (typeof(TDestination).IsArray)
                  {
                      var elementType = typeof(TDestination).GetElementType();
                      var listType = typeof(List<>).MakeGenericType(elementType);
                      var list = (System.Collections.IList)Activator.CreateInstance(listType);
                      foreach (var item in enumerable)
                      {
                          var mappedItem = this.GetType().GetMethod("Map").MakeGenericMethod(elementType).Invoke(this, new object[] { item });
                          list.Add(mappedItem);
                      }
                      var array = Array.CreateInstance(elementType, list.Count);
                      list.CopyTo(array, 0);
                      return (TDestination)(object)array;
                  }
                  if (typeof(TDestination).IsGenericType && ( typeof(TDestination).GetGenericTypeDefinition() == typeof(List<>) ||
                                                              typeof(TDestination).GetGenericTypeDefinition() == typeof(IEnumerable<>)  ||
                                                              typeof(TDestination).GetGenericTypeDefinition() == typeof(ICollection<>)  || 
                                                              false
                      ))
                  {
                      var elementType = typeof(TDestination).GetGenericArguments()[0];
                      var list = (System.Collections.IList)Activator.CreateInstance(typeof(List<>).MakeGenericType(elementType));
                      foreach (var item in enumerable)
                      {
                          var mappedItem = this.GetType().GetMethod("Map").MakeGenericMethod(elementType).Invoke(this, new object[] { item });
                          list.Add(mappedItem);
                      }
                      return (TDestination)list;
                  }
                  else
                  {
                      return OnError<TDestination>(source, new NotImplementedException($"Mapping to collection type {typeof(TDestination).FullName} is not supported."));
                  }
              }
              
              
              public virtual TDestination Map<TDestination>(object source)
              {
                  if (source == null)
                  {
                      return OnNull<TDestination>();
                  }
                  
                  
                  // if source is iEnumerable
                  if (source is System.Collections.IEnumerable enumerable)
                  {
                      return OnEnumerable<TDestination>(source);
                  }
          
          
                  // if source has a mapping method to TDestination, use it
                  var mapMethod = source.GetType().GetMethod("MapTo", new Type[] { typeof(IMapper) });
                  var mapFromMethod = typeof(TDestination).GetMethod("MapFrom", new Type[] { typeof(IMapper), source.GetType() });
                  
                  return OnMap<TDestination>(source, mapMethod, mapFromMethod);
              }
          }
          
           
          """, Encoding.UTF8);
        return sourceText;
    }

    private static SourceText GenerateAttributeSourceText(AttributeDefinition attribute)
    {
        var src = new StringBuilder();
        src.AppendLine("// <auto-generated/>");
        src.AppendLine("using System;");
        src.AppendLine();
        src.AppendLine($"namespace {Consts.AttributesNamespace}");
        src.AppendLine("{");
        src.AppendLine($"    /// <summary>");
        src.AppendLine($"    /// {attribute.Description}");
        src.AppendLine($"    /// </summary>");
        src.AppendLine($"    [AttributeUsage(AttributeTargets.Class)]");
        src.AppendLine($"    public class {attribute.Name}Attribute (");
        foreach (var arg in attribute.Arguments)
        {
            var comma = arg != attribute.Arguments.Last() ? "," : "";
            src.AppendLine($"        {arg.Type} {arg.Name}{comma} // {arg.Value}");
        }
        for (int i = 0; i < attribute.Arguments.Count; i++)
        {
            var arg = attribute.Arguments[i];
            var comma = i < attribute.Arguments.Count - 1 ? "," : "";
        }
        
        src.AppendLine("     ): Attribute{");
        src.AppendLine("    }");
        src.AppendLine("}");
        return SourceText.From(src.ToString(), Encoding.UTF8);
    }
}